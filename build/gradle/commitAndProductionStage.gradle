// Fraunhofer Institute for Computer Graphics Research (IGD)
// Department Spatial Information Management (GEO)
//
// Copyright (c) 2013-2014 Fraunhofer IGD.
//
// This file is part of hale-build.
//
// hale-build is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// hale-build is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with hale-build.  If not, see <http://www.gnu.org/licenses/>.

import groovy.text.GStringTemplateEngine

import java.nio.file.Files;
import java.text.SimpleDateFormat
import org.yaml.snakeyaml.Yaml
import org.apache.maven.cli.MavenCli
import org.apache.tools.ant.taskdefs.condition.Os

/**
 * @return the value of the 'productFile' property
 */
def getProductFile() {
    if (!project.ext.properties.containsKey("productFile")) {
        throw new IllegalStateException("Please specify a product file to build:\n\n    -PproductFile=<path_to_product_file>\n\n")
    }
    return project.ext.productFile
}

/**
 * @return the unique id of the product file to build
 */
def getProductUid() {
    def dlcdoc = new XmlSlurper().parse(project.file(getProductFile()))
    def uid = dlcdoc.@uid
    if (uid == null) {
        throw new IllegalStateException('Product needs a valid uid')
    }
    return uid.toString()
}

/**
 * @return the id of the product definition
 */
def getProductId() {
	def dlcdoc = new XmlSlurper().parse(project.file(getProductFile()))
	def id = dlcdoc.@id
	if (id == null) {
		throw new IllegalStateException('Product needs a valid id')
	}
	return id.toString()
}

/**
 * @return the name of the product definition
 */
def getProductName() {
	def dlcdoc = new XmlSlurper().parse(project.file(getProductFile()))
	def name = dlcdoc.@name
	if (name == null) {
		throw new IllegalStateException('Product needs a valid name')
	}
	return name.toString()
}

/**
 * Get the symbolic name of the bundle that contains the product definition
 */
def getProductDefiningBundleName() {
	String productId = getProductId()
	productId[0..productId.lastIndexOf('.')-1]
}

/**
 * @return the name of the launcher defined in the product to build
 */
def getProductLauncher() {
    def dlcdoc = new XmlSlurper().parse(project.file(getProductFile()))
    def name = null
    dlcdoc.launcher.each { name = it.@name }
    if (name == null) {
        throw new IllegalStateException('Product needs a valid launcher name')
    }
    return name.toString()
}

/**
 * @return the product version, includes the qualifier for SNAPSHOTS
 */
String productVersion(String version) {
	def qualifier = project.ext.contextQualifier

	if (version.endsWith('.qualifier')) {
		// replace qualifier (omit if release)
		version[0..-11] + ((qualifier == 'release')?(''):('.' + qualifier))
	}
	else if (version.endsWith('-SNAPSHOT')) {
		// replace SNAPSHOT (omit if release)
		version[0..-10] + ((qualifier == 'release')?(''):('.' + qualifier))
	}
	else {
		// return as-is
		version
	}
}

/**
 * @return the name of the package which is created by
 * packageServer() or packageClient()
 */
def getPackageName() {
    def tag
    if (project.ext.properties.containsKey('tag')) {
        tag = project.ext.tag + '-'
    } else {
        tag = ''
    }
    return getProductName().replaceAll(' ', '-') + '-' + productVersion(project.version) + '-' + tag +
            project.ext.osgiOS + '.' + project.ext.osgiWS + '.' + project.osgiArch
}

/**
 * @return 'true' if the product to build contains the 'org.eclipse.ui' bundle
 */
def productContainsUIBundles() {
    def dlcdoc = new XmlSlurper().parse(project.file(getProductFile()))
	if (dlcdoc.@useFeatures.toString() == 'true') {
		// defined through features
		return !(dlcdoc.features.feature.any { it.@id.toString().contains('server') })
	}
	else {
		// defined through bundles
		return dlcdoc.plugins.plugin.any { it.@id.toString() == 'org.eclipse.ui' }
	}
}

/**
 * @return 'true' if the product to build contains HALE I/O bundles
 */
def productContainsHaleIOBundles() {
    def dlcdoc = new XmlSlurper().parse(project.file(getProductFile()))
	if (dlcdoc.@useFeatures.toString() == 'true') {
		// defined through features
		return (dlcdoc.features.feature.any { it.@id.toString().contains('eu.esdihumboldt.hale.io') })
	}
	else {
		// defined through bundles
		return dlcdoc.plugins.plugin.any { it.@id.toString().contains('eu.esdihumboldt.hale.io') }
	}
}

/**
 * Extracts the product definition for a product with a given
 * name from the given hash of product definitions (see files
 * templates/products/client.yaml and server.yaml for examples)
 */
def makeProductDef(productDefs, productName) {
    // check if the product definition contains a product with the given name
    if (!productDefs.containsKey(productName)) {
        throw new IllegalStateException("Unknown product name: ${productName}")
    }

    def d = productDefs[productName]

    // handle 'Extends' keyword
    if (d.containsKey('Extends')) {
        // make product definition for parent product
        def e = makeProductDef(productDefs, d['Extends'])

        // remove 'Extends' value from product definition
        d.remove('Extends')

        // for each key-value pair, overwrite pairs from parent
        // product or add values to existing arrays
        d.each {
            if (it.value instanceof List && e[it.key] != null) {
                e[it.key] += it.value
            } else {
                e[it.key] = it.value
            }
        }

        // replace product definition by extended one
        d = e
    }

    return d
}

/**
 * Copies a template file from src to dst and replaces the
 * given values using GStringTemplateEngine
 */
def renderTemplate(src, dst, values) {
    dst.withWriter { w ->
        def template = new GStringTemplateEngine().createTemplate(src)
        def result = template.make(values).toString()
        w << result
    }
}

/**
 * Remove platform-specific fragments from the given product file
 * FIXME remove this once Tycho knows how to handle platform-specific
 * fragments on its own. See BUG 342890
 * https://bugs.eclipse.org/bugs/show_bug.cgi?id=342890
 */
def filterPlatformSpecificFragments(productFile) {
    def bundlesToRemove = []
	def featuresToRemove = []

    def productFileContents = productFile.text
    def dlcdoc = new XmlSlurper().parseText(productFileContents)
    dlcdoc.plugins.plugin.each { p ->
        def id = p.@id.toString()
		/*
		 * Find platform specific bundles based on the symbolic name.
		 * Platform specific bundles provided by Eclipse/Equinox usually
		 * contain the tested strings in the symbolic name, but this is
		 * only a workaround as the information really is encoded in the
		 * manifest of each bundle.
		 */
        if (id.contains('x86') || id.contains('i586') || id.contains('macosx')) {
            // found a platform-specific bundle
            // check architecture
            def is64bit = id.contains('x86_64')
            if (is64bit != Helper.buildFor64bit(project)) {
                bundlesToRemove << id
            } else {
                // check OS
                if (!id.contains(project.ext.osgiOS)) {
                    bundlesToRemove << id
                }
            }
        }
		/*
		 * Find OS specific bundles.
		 */
		if (project.ext.properties.containsKey('osSpecificBundles')) {
			def os = project.ext.osSpecificBundles[id]
			if (os && !os.any { it == project.ext.osgiOS}) {
				// OS information is there but does not match
				bundlesToRemove << id
			}
		}
    }

	// also check features
	dlcdoc.features.feature.each { f ->
		def id = f.@id.toString()
		/*
		 * Find OS specific features.
		 */
		if (project.ext.properties.containsKey('osSpecificBundles')) {
			def os = project.ext.osSpecificBundles[id]
			if (os && !os.any { it == project.ext.osgiOS}) {
				// OS information is there but does not match
				featuresToRemove << id
			}
		}
	}

	def notPlatformBundles = new HashSet(project.ext.notPlatformSpecificBundles ?: [])
	
    // remove bundles from product file
    bundlesToRemove.each { p ->
		if (!notPlatformBundles.contains(p)) {
			productFileContents = productFileContents.replaceAll(/<plugin.*id="${p}".+\r?\n\s+/, '')
			println "Removed platform specific bundle $p from product configuration"
		}
    }

	// remove features from product file
	featuresToRemove.each { f ->
		productFileContents = productFileContents.replaceAll(/<feature.*id="${f}".+\r?\n\s+/, '')
		println "Removed platform specific feature $f from product configuration"
	}

    // overwrite product file
    productFile.write(productFileContents, 'UTF-8')
}

/**
 * Replaces the paths to icons in the given product file
 * by absolute ones. Assumes that the paths are specified using the
 * symbolic name of the bundle containing the icon and that they start with
 * a slash. For example, if the path is '/de.cs3d.admintool/icons/cs3d.ico'
 * this method will replace the substring 'de.cs3d.admintool' by the absolute
 * path to the bundle 'de.cs3d.admintool'.
 */
def replaceIconPaths(productFile) {
    def replacements = [:]

    def productFileContents = productFile.text
    def product = new XmlSlurper().parseText(productFileContents)
	
	// .ico file
    product.launcher.win.ico.each { i ->
        def path = i.@path.toString()
        if (path.startsWith('/')) {
            def symbolicName = path.replaceAll(/^\/([^\/]+)\/.*/, '$1')
            def pb = new BundleParser(project).getParsedBundles()[symbolicName]
            if (pb != null) {
                replacements[/<ico(.*)path="\/${symbolicName}\/([^>]+)>/] = '<ico$1path="' + pb.path.path.replace('\\', '/') + '/$2>'
            }
        }
    }
	// .bmp icon files
	product.launcher.win.bmp.each {
		it.attributes().each { name, value ->
			def path = value as String
			if (path.startsWith('/')) {
				def symbolicName = path.replaceAll(/^\/([^\/]+)\/.*/, '$1')
				def pb = new BundleParser(project).getParsedBundles()[symbolicName]
				if (pb != null) {
					replacements[/${name}="\/${symbolicName}\/([^"]+)"/] = name + '="' + pb.path.path.replace('\\', '/') + '/$1"'
				}
			}
		}
	}
	
	// Linux icon
	product.launcher.linux.each { i ->
		def path = i.@icon.toString()
		if (path.startsWith('/')) {
			def symbolicName = path.replaceAll(/^\/([^\/]+)\/.*/, '$1')
			def pb = new BundleParser(project).getParsedBundles()[symbolicName]
			if (pb != null) {
				replacements[/<linux(.*)icon="\/${symbolicName}\/([^>]+)>/] = '<linux$1icon="' + pb.path.path.replace('\\', '/') + '/$2>'
			}
		}
	}
	
	// Mac OS X icon
	product.launcher.macosx.each { i ->
		def path = i.@icon.toString()
		if (path.startsWith('/')) {
			def symbolicName = path.replaceAll(/^\/([^\/]+)\/.*/, '$1')
			def pb = new BundleParser(project).getParsedBundles()[symbolicName]
			if (pb != null) {
				replacements[/<macosx(.*)icon="\/${symbolicName}\/([^>]+)>/] = '<macosx$1icon="' + pb.path.path.replace('\\', '/') + '/$2>'
			}
		}
	}

    // replace icon paths
    replacements.each { org, replacement ->
        productFileContents = productFileContents.replaceAll(org, replacement)
    }

    // overwrite product file
    productFile.write(productFileContents, 'UTF-8')
}

/*
 * Downloads platform specific artifacts from '<artifactsMirrorUrl>/relsrcpath'
 * and unzips them to 'reldstpath'. Prints 'name' to the console.
 */
def includeAdditionalFiles(artifacts, relsrcpath, productOutputPath, reldstpath, name) {
    if (artifacts.containsKey(project.ext.osgiOS) && artifacts[project.ext.osgiOS].containsKey(project.ext.osgiWS) &&
            artifacts[project.ext.osgiOS][project.ext.osgiWS].containsKey(project.ext.osgiArch)) {
        // Download artifact
        def f = artifacts[project.ext.osgiOS][project.ext.osgiWS][project.ext.osgiArch]
        def artifactZipPath = new File(buildDir, f)
        def artifactZipPathPart = new File(buildDir, f + '.part')
        def artifactDownloadUrl = project.ext.artifactsMirrorUrl + '/' + relsrcpath + '/' + f
        if (!artifactZipPath.exists()) {
            download.run {
                src artifactDownloadUrl
                dest artifactZipPathPart
                overwrite true
            }
            artifactZipPathPart.renameTo(artifactZipPath)
        }

        // Unzip artifact
        println('Copying ' + name + ' ...')
        def artifactInstallPath = new File(productOutputPath, reldstpath)
        if (artifactZipPath.name.endsWith('.zip')) {
            ant.unzip(src: artifactZipPath, dest: artifactInstallPath)
        } else {
		    if (!Helper.buildForMac(project)) {
		        ant.untar(src: artifactZipPath, dest: artifactInstallPath, compression: 'gzip')
		    } else {
				//It is certain that this code will run when creating build for mac.
				//Therefore, the jre must be copied into the `Eclipse` folder of the bundled application.
				artifactInstallPath = new File(productOutputPath.absolutePath ,"/Eclipse.app/Contents/Eclipse/${reldstpath}")
				
				// Use external tar command for OSX build since the jdk to bundle with HALE, contains symbolic links.
				// This does only work on UNIX-based systems with tar installed!
				//This command during extraction, will strip the root folder from jdk which is usually jdk name and will
				//extract the data into root folder starting with `Contents`.
				def command = ['tar', '--preserve-permissions','-xzf', artifactZipPath.absolutePath, '--strip-components=1']
				if (Os.isFamily(Os.FAMILY_MAC)) {
					command = ['gtar', '--preserve-permissions','-xzf', artifactZipPath.absolutePath, '--strip-components=1']
				} 
			    artifactInstallPath.mkdir()
			 	try {
				    // On windows, an IOException will be thrown here
			    	def proc = command.execute(null, artifactInstallPath)
				    def buffer = new StringBuffer()
				    proc.consumeProcessErrorStream(buffer)
			    	    proc.waitFor()
				    // If unpacking fails on linux/osx just handle it the same way
				    if (proc.exitValue() != 0) {
				        throw new IOException("${buffer.toString()}")
				    }
				} catch (ex) {
				    throw new IllegalStateException("Unable to unpack ${name} - The MacOSX build requires a UNIX-based system with tar installed:\n${ex.toString()}")
				}
				if (reldstpath.equals("jre")){
					//update HALE.ini file with the JRE path bundled in the Eclipse.app.
					def launcherName=  getProductLauncher()
					updateHaleIniFileWithJrePath(productOutputPath.absolutePath + "/Eclipse.app/Contents/Eclipse/${launcherName}.ini")
				}
			}
        }
    } else {
        println('Cannot find ' + name + ' for this platform. ' + name + ' will not be copied into the product.')
    }
}

/**
 * Replace placeholders in product about text with information on build and revision.
 */
void updateAboutInfo(productOutputPath) {
	def productBundle = getProductDefiningBundleName()

	def jars = fileTree(dir: productOutputPath, includes: [ "**/plugins/${productBundle}_*.jar" ])
	if (jars.isEmpty()) {
		println "Could not find product defining bundle $productBundle"
		return
	}

	println "Updating about information in ${productBundle}..."

	File productBundleJar = jars.iterator().next()
	File tmpDir = Files.createTempDirectory('product-app').toFile()

	// extract product bundle to temporary directory
	println "Extracting product bundle ${productBundleJar}"
	ant.unzip(src: productBundleJar, dest: tmpDir)

	// determine revision
	def revision = System.getenv()['GIT_COMMIT'] // set by jenkins
	if (!revision) {
		// determine commit ID from checkout
		//TODO configure directory?
		revision = GitHelper.currentCommitId(new File(rootDir.parentFile, '.git'))
	}
	if (!revision) {
		// unable to detect revision
		revision = 'unknown'
	}

	// determine version from manifest
	File manifestFile = new File(tmpDir, 'META-INF/MANIFEST.MF')
	def bundleVersion = new BundleParser(project).readVersion(manifestFile, true)

	// replace tokens in plugin.xml
	File pluginXml = new File(tmpDir, 'plugin.xml')
	ant.replace(file: pluginXml, token: '___build___', value: project.ext.buildId, summary: true)
	ant.replace(file: pluginXml, token: '___revision___', value: revision, summary: true)
	ant.replace(file: pluginXml, token: '___version___', value: bundleVersion, summary: true)
	
	// update original jar with updated plugin.xml
	ant.jar(update: 'true', destfile: productBundleJar) {
		fileset(dir: tmpDir, includes: 'plugin.xml')
	}
	
	// special case handling: replace information in help banner
	File bannerFile = new File(new File(tmpDir, 'html'), 'banner.html')
	if (bannerFile.exists()) {
		println "Replacing placeholders in help banner..."
		ant.replace(file: bannerFile, token: '___version___', value: bundleVersion, summary: true)
		
		// update original jar with updated banner.html
		ant.jar(update: 'true', destfile: productBundleJar) {
			fileset(dir: tmpDir, includes: 'html/banner.html')
		}
	}

	tmpDir.deleteDir()
}

/**
 * Creates an installable package for the client
 */
def packageClient(productOutputPath) {
    if (Helper.buildForWindows(project)) {
		boolean packageAsZip = project.hasProperty('noInstaller') && project.ext.noInstaller

		if (!packageAsZip) {
			try {
		        // get path to Windows Installer XML Kit
		        if (!project.ext.properties.containsKey("wixDir")) {
					//Getting unrequired directory so need to provide Program files directories 
//		            def dirs = fileTree(dir: 'C:\\', includes: [ 'Program Files*\\Windows Installer XML v3*\\bin\\candle.exe',
//		                    'Program Files*\\WiX Toolset v3*\\bin\\candle.exe' ])
					
					def dirs = fileTree(dir: 'C:\\Program Files\\', includes: [ 'Windows Installer XML v3*\\bin\\candle.exe',
						'WiX Toolset v3*\\bin\\candle.exe' ]) + fileTree(dir: 'C:\\Program Files (x86)\\', includes: [ 'Windows Installer XML v3*\\bin\\candle.exe',
						'WiX Toolset v3*\\bin\\candle.exe' ])

		            if (dirs.isEmpty()) {
		                throw new IllegalStateException("Could not guess WIX installation directory. Please specify it " +
		                        "in the 'wixDir' property")
		            }

		            if (dirs.files.size() > 1) {
		                throw new IllegalStateException("More than one WiX installation found. Please select the right " +
		                        "one in the 'wixDir' property")
		            }

		            project.ext.wixDir = dirs.singleFile.parentFile.parentFile
		            println('Guessing WIX directory: ' + project.ext.wixDir)
		        }

		        // call legacy Ant file to build the Windows installer
		        def wixArch
		        if (Helper.buildFor64bit(project)) {
		            wixArch = 'x64'
		        } else {
		            wixArch = 'x86'
		        }
		        ant.ant(antfile: new File("ant", "build-msi.xml")) {
		            property(name: "buildId", value: getProductLauncher())
		            property(name: "shortName", value: getProductLauncher())
		            property(name: "title", value: project.ext.win32InstallerTitle)
		            property(name: "version", value: productVersion(project.version))
		            property(name: "GUID.UpgradeCode", value: project.ext.win32InstallerUpgradeGUID)
		            property(name: "GUID.ApplicationShortcut", value: project.ext.win32InstallerShortcutGUID)
		            if (project.ext.properties.containsKey('tag')) {
		                property(name: "tag", value: project.ext.tag)
		            }
		            property(name: "wix.arch", value: wixArch)
		            if (project.ext.properties.containsKey('language')) {
		                property(name: "language", value: project.ext.language)
		            } else {
		                property(name: "language", value: 'en')
		            }
		            property(name: "wix.dir", value: project.ext.wixDir)
		            property(name: "wxs.dir", value: Helper.resolveTemplate(project, 'wix'))
		            property(name: "wxs.file.ui", value: "WixUI_Product")
		            property(name: "wxs.file.config", value: "WixProduct")
		            property(name: "src", value: productOutputPath)
		        }
			} catch (e) {
				println "Could not find WiX installation ($e.message), packaging as ZIP instead"

				packageAsZip = true
			}
		}

		if (packageAsZip) {
			// package as ZIP
			def packageName = getPackageName()
			def packageFileName = new File('target', packageName + '.zip')

			println('Creating package ' + packageFileName + ' ...')
			ant.zip(destfile: packageFileName) {
				zipfileset(dir: productOutputPath, prefix: packageName)
			}
		}
    } else if (Helper.buildForLinux(project)) {
		// Linux
		// package as .tar.gz
        def packageName = getPackageName()
        def packageFileName = new File('target', packageName + '.tar.gz')
		def launcherName = getProductLauncher()

        println('Creating package ' + packageFileName + ' ...')
        ant.tar(destfile: packageFileName, longfile: 'gnu', compression: 'gzip') {
            tarfileset(dir: productOutputPath, prefix: packageName) {
                exclude(name: getProductLauncher())
                exclude(name: '**/*.sh')
                exclude(name: '**/*.so')
                exclude(name: '**/jre/bin/*')
            }
            tarfileset(dir: productOutputPath, prefix: packageName, filemode: '755') {
                include(name: getProductLauncher())
                include(name: '**/*.sh')
                include(name: '**/*.so')
                include(name: '**/jre/bin/*')
            }
        }
    } else {
		// OSX
		// package as .tar.gz using external tar command to preserve symbolic links in jdk
		def packageName = getPackageName()
		def launcherName = getProductLauncher()
		def productName = getProductName()

		// rename app
		def mvCmd = ['mv', 'Eclipse.app', "${productName}.app"]
		def mvProc = mvCmd.execute(null, productOutputPath)
		def mvBuffer = new StringBuffer()
		mvProc.consumeProcessErrorStream(mvBuffer)
		mvProc.waitFor()
		
		// Set file permissions
		def permCmd = ['chmod', '755', "${productName}.app/Contents/MacOS/${launcherName}"]
		def permProc = permCmd.execute(null, productOutputPath)
		def permBuffer = new StringBuffer()
		permProc.consumeProcessErrorStream(permBuffer)
		permProc.waitFor()
		if (permProc.exitValue() != 0) {
		    println("Exit value is ${permProc.exitValue()}")
		    println("ls".execute(null, productOutputPath).text)
		    throw new IllegalStateException("Unable to set required file permissions:\n${permBuffer.toString()}");
		}

		// Copy Info.plist template and replace variables
		def copyCmd = ['cp', '../../templates/macos/Info.plist', "${productName}.app/Contents"]
		def copyProc = copyCmd.execute(null, productOutputPath)
		def copyBuffer = new StringBuffer()
		copyProc.consumeProcessErrorStream(copyBuffer)
		copyProc.waitFor()
		if (copyProc.exitValue() != 0) {
		    println("Exit value is ${copyProc.exitValue()}")
		    println("ls".execute(null, productOutputPath).text)
		    throw new IllegalStateException("Unable to copy Info.plist:\n${copyBuffer.toString()}");
		}
		def versionYear = new Date().format('yyyy')
		def bundleVersion = productVersion(project.version)
		File infoPlist = new File(productOutputPath, "${productName}.app/Contents/Info.plist")
		ant.replace(file: infoPlist, token: '___version___', value: bundleVersion, summary: true)
		ant.replace(file: infoPlist, token: '___versionYear___', value: versionYear, summary: true)
		ant.replace(file: infoPlist, token: '___launcherName___', value: launcherName, summary: true)
		ant.replace(file: infoPlist, token: '___productName___', value: productName, summary: true)

		// Pack tar archive
		println('Creating package ' + packageName + '.tar.gz' + ' ...')
		def targetDir = new File(productOutputPath.absolutePath + '/../../target')
		targetDir.mkdir()
		def tarPath = targetDir.absolutePath + '/' + packageName + '.tar.gz';
		def packCmd =  ['tar', '--preserve-permissions', '-czf', tarPath, '--transform', "s,^\\./,$packageName/,", '.']
		//If the build script is run on the OS X then use gtar command.
		//Note: gtar must be installed using `brew install gnu-tar`.
		if (Os.isFamily(Os.FAMILY_MAC)) {
			packCmd =  ['gtar', '--preserve-permissions', '-czf', tarPath, '--transform', "s,^\\./,$packageName/,", '.']
		}
		def packProc = packCmd.execute(null, productOutputPath)
		def packBuffer = new StringBuffer()
		packProc.consumeProcessErrorStream(packBuffer)
		packProc.waitFor()
		if (packProc.exitValue() != 0) {
		    throw new IllegalStateException("Unable to create tar archive:\n${packBuffer.toString()}");
		}

		println("Creating package ${packageName}.dmg ...")
		// Copy .DS_Store
		def copyDSCmd = ['cp', '../../templates/macos/DS_Store.template', ".DS_Store"]
		def copyDSProc = copyDSCmd.execute(null, productOutputPath)
		def copyDSBuffer = new StringBuffer()
		copyDSProc.consumeProcessErrorStream(copyDSBuffer)
		copyDSProc.waitFor()
		if (copyDSProc.exitValue() != 0) {
		    println("Exit value is ${copyDSProc.exitValue()}")
		    println("ls".execute(null, productOutputPath).text)
		    println("Unable to copy .DS_Store:\n${copyDSBuffer.toString()}");
		}

		// Add link to /Applications
		def lnAppCmd = ['ln', '-s', '/Applications', "Applications"]
		def lnAppProc = lnAppCmd.execute(null, productOutputPath)
		def lnAppBuffer = new StringBuffer()
		lnAppProc.consumeProcessErrorStream(lnAppBuffer)
		lnAppProc.waitFor()
		if (lnAppProc.exitValue() != 0) {
		    println("Exit value is ${lnAppProc.exitValue()}")
		    println("ls".execute(null, productOutputPath).text)
		    println("Unable to create /Applications link:\n${lnAppBuffer.toString()}");
		}

		// Generate DMG image
		def genisoCmd = ['genisoimage', '-V', "${productName} ${bundleVersion}", '-D', '-R', '-apple', '-no-pad', '-o', "${targetDir}/${packageName}.dmg", '.']
		//create dmg file if the script is run on mac OS.
		if (Os.isFamily(Os.FAMILY_MAC)) {
			genisoCmd = "hdiutil create -ov -format UDZO -srcfolder ${productOutputPath.absolutePath} ${targetDir}/${packageName}.dmg"
		}
		def genisoProc = genisoCmd.execute(null, productOutputPath)
		def genisoBuffer = new StringBuffer()
		genisoProc.consumeProcessErrorStream(genisoBuffer)
		genisoProc.waitFor()
		if (genisoProc.exitValue() != 0) {
		    println("Exit value is ${genisoProc.exitValue()}")
		    println("ls".execute(null, productOutputPath).text)
		    println("Unable to create DMG image:\n${genisoBuffer.toString()}");
		}
    }
}

/**
 * Creates an installable package for the server
 */
def packageServer(productOutputPath) {
    // Include launchers
    def launcherName = getProductLauncher()
    if (Helper.buildForLinux(project) || Helper.buildForMac(project)) {
        def values = [
            'launcher': launcherName
        ]
        def srcPath = Helper.resolveTemplate(project, 'startup/server/linux')
        renderTemplate(new File(srcPath, 'launcher.sh'), new File(productOutputPath, "${launcherName}.sh"), values)
        renderTemplate(new File(srcPath, 'shutdown.sh'), new File(productOutputPath, 'shutdown.sh'), values)
        renderTemplate(new File(srcPath, 'startup.sh'), new File(productOutputPath, 'startup.sh'), values)
    } else if (Helper.buildForWindows(project)) {
        def srcPath = Helper.resolveTemplate(project, 'startup/server/win32')

        // copy service launcher
        def serviceLauncher = project.ext.serviceExeName + '.exe'
        def serviceWrapper = (Helper.buildFor64bit(project) ? 'jsl64.exe' : 'jsl.exe')
        project.copy {
            from new File(srcPath, serviceWrapper)
            into productOutputPath
            rename { serviceLauncher }
        }

        // read command line from ini file
        def iniFile = new File(productOutputPath, "${launcherName}.ini").text
        def programArgs = iniFile.replaceAll(/\r?\n+/, ' ').replaceAll(/-vmargs.*/, '').trim()
        def vmArgs = iniFile.replaceAll(/\r?\n+/, ' ').replaceAll(/.*-vmargs/, '').trim()

        // find launcher jar
        def launcherJar = 'plugins/' + fileTree(dir: new File(productOutputPath, 'plugins'),
                include: 'org.eclipse.equinox.launcher*.jar').files.toList()[0].name

        def values = [
            'launcher': launcherName,
            'serviceName': project.ext.serviceName,
            'serviceShort': project.ext.serviceExeName,
            'cmdLine': "${vmArgs} -jar ${launcherJar} ${programArgs}"
        ]
        renderTemplate(new File(srcPath, 'service-install.bat'), new File(productOutputPath, 'service-install.bat'), values)
        renderTemplate(new File(srcPath, 'service-remove.bat'), new File(productOutputPath, 'service-remove.bat'), values)
        renderTemplate(new File(srcPath, 'jsl.ini'), new File(productOutputPath, "${project.ext.serviceExeName}.ini"), values)
    }

    // create package
    def packageName = getPackageName()
    def packageFileName
    if (Helper.buildForWindows(project)) {
        packageFileName = new File("target/${packageName}.zip")
    } else {
        packageFileName = new File("target/${packageName}.tar.gz")
    }

    println("Creating package ${packageFileName} ...")
    if (Helper.buildForWindows(project)) {
        ant.zip(destfile: packageFileName) {
            zipfileset(dir: productOutputPath, prefix: packageName)
        }
    } else {
        ant.tar(destfile: packageFileName, longfile: 'gnu', compression: 'gzip') {
            tarfileset(dir: productOutputPath, prefix: packageName) {
                exclude(name: launcherName)
                exclude(name: '**/*.sh')
                exclude(name: '**/*.so')
                exclude(name: '**/jre/bin/*')
				exclude(name: launcherName)
				exclude(name: "${productName}.app/Contents/MacOS/${launcherName}")
            }
            tarfileset(dir: productOutputPath, prefix: packageName, filemode: '755') {
                include(name: launcherName)
                include(name: '**/*.sh')
                include(name: '**/*.so')
                include(name: '**/jre/bin/*')
				include(name: launcherName)
				include(name: "${productName}.app/Contents/MacOS/${launcherName}")
            }
        }

        // Docker image
        // right now mainly intended for Infocenter product
        if (Helper.buildForLinux(project) && project.ext.dockerImageName) {
            def dockerDir = new File(buildDir, 'docker-build')

            // copy artifact
            copy {
                from packageFileName
                into dockerDir
            }

            // create Dockerfile
            new File(dockerDir, 'Dockerfile').text = """
                |FROM ubuntu:16.04
                |ADD ${packageName}.tar.gz /opt
                |RUN sed -i "s/-Dserver_port=.*/-Dserver_port=80/" /opt/${packageName}/${launcherName}.ini && \\
                |  sed -i "s/-Dserver_host=.*/-Dserver_host=0.0.0.0/" /opt/${packageName}/${launcherName}.ini
                |EXPOSE 80
                |WORKDIR /opt/${packageName}
                |CMD ./${launcherName}
            """.trim().stripMargin()

            // build docker image
			def buildCommand = [
                'docker',
                'build',
                '-t',
                "${project.ext.dockerImageName}:${project.version}"
            ]
			if (project.ext.dockerTagLatest == true) {
				// also create tag :latest
				buildCommand << '-t'
				buildCommand << "${project.ext.dockerImageName}:latest"
			}
			buildCommand << dockerDir.absolutePath as String
            def buildProcess = buildCommand.execute()
            buildProcess.waitForProcessOutput(System.out, System.err)
            if (buildProcess.exitValue() != 0) {
                throw new IllegalStateException("Building docker image failed with exit code ${buildProcess.exitValue()}")
            }

            // push docker image
            if (project.ext.publishProduct == true) {
                def pushProcess = ([
                    'docker',
                    'push',
                    "${project.ext.dockerImageName}:${project.version}",
                ]).execute()
                pushProcess.waitForProcessOutput(System.out, System.err)
                if (pushProcess.exitValue() != 0) {
                    throw new IllegalStateException("Pushing docker image failed with exit code ${pushProcess.exitValue()}")
                }
				
				if (project.ext.dockerTagLatest == true) {
					// also push :latest tag
					def pushLatest = ([
						'docker',
						'push',
						"${project.ext.dockerImageName}:latest",
					]).execute()
					pushLatest.waitForProcessOutput(System.out, System.err)
					if (pushLatest.exitValue() != 0) {
						throw new IllegalStateException("Pushing docker image failed with exit code ${pushProcess.exitValue()}")
					}
				}
            }
        }
    }
}

/**
 * Method executed only for OS X. 
 * To run the HALE studio in mac, JRE must be bundled within the HALE studio app
 * and its location must be added in the HALE.ini file.
 * This method is a work around to modify HALE.ini file.
 * This method reads HALE.ini file stored under "~/Eclipse.app/Contents/Eclipse/HALE.ini",
 * then appends "-vm" arguments along with the JRE location bundled within the application.
 * Finally, the changes are written back to the "HALE.ini" file.
 * filepath HALE.ini file path
 */
def updateHaleIniFileWithJrePath(filepath) {

	File file = new File(filepath)
	def fileContent = file.getText();

	def indexOfVmargs = fileContent.indexOf("-vmargs")
	
	def updatedContent = fileContent.substring(0, indexOfVmargs)
	.concat("-vm\n")
	.concat("../Eclipse/jre/Contents/Home/bin/java\n")
	.concat(fileContent.substring(indexOfVmargs, fileContent.length()))

	println("HALE.ini file contents changed successfully!!")
	file.write(updatedContent)
}

task makeProductFeatureProjectDefinition(type: Copy) {
    from Helper.resolveTemplate(project, 'plugin-project.xml')
    into new File(buildDir, 'gen.product.feature')
    rename { '.project' }
}

/**
 * Creates a temporary product file to build from. Uses the 'productType'
 * and 'productName' environment variables to select a template for the
 * product. Does nothing if these both variables are not set, but
 * 'productFile' is set instead.
 * After creating the product file, this method will set the 'productFile'
 * environment variable in order to let subsequent tasks know about the
 * path to the new temporary product file.
 */
task makeProductFile {
	doLast {
	    // check environment variables
		if (project.ext.has('productFile')) {
			// if a product file is given, prefer it over any productType/productName properties
		} else if ((project.ext.properties.containsKey("productType") && !project.ext.properties.containsKey("productName")) ||
	        (!project.ext.properties.containsKey("productType") && project.ext.properties.containsKey("productName"))) {
	        throw new IllegalStateException("Please specify the parameters 'productType' and 'productName'")
	    } else if (!project.ext.properties.containsKey("productType") && !project.ext.properties.containsKey("productName")) {
	        // make sure 'productFile' is given instead
	        getProductFile()
	    } else {
	        def productType = project.ext.productType
	        def productName = project.ext.productName
	
	        // load product definition
	        def productDefsFile = Helper.resolveTemplate(project, "products/${productType}.yaml")
	        if (!productDefsFile.exists()) {
	            throw new IllegalStateException("Unknown product type: ${productType}")
	        }
	        def productDefs = new Yaml().load(productDefsFile.newReader())
	
	        // parse product definition (e.g. process 'Extends' directives, etc.)
	        def productDef = makeProductDef(productDefs, productName)
	
	        // add target version to product definition (so it can be
	        // used in the product template)
	        productDef['Version'] = formatBundleVersion(project.version) //TODO check if this method defined in updateSite.gradle is accessible
	
	        // parse plugins and add start levels to product definition
	        def startLevels = []
	        def plugins = []
	        productDef['Plugins'].each { p ->
	            def at = p.indexOf('@')
	            if (at >= 0) {
	                def name = p.substring(0, at)
	                def level = p.substring(at + 1)
	                startLevels << [
	                    'Name': name,
	                    'StartLevel': level
	                ]
	                p = name
	            }
	            plugins << p
	        }
	        productDef['Plugins'] = plugins
	        productDef['StartLevels'] = startLevels
	
	        if (!productDef.containsKey('AboutImagePath')) {
	            productDef['AboutImagePath'] = null
	        }
	        if (!productDef.containsKey('WinIco')) {
	            productDef['WinIco'] = null
	        }
	
	        // render product template using the parsed product definition
	        def productFileTemp = new File(buildDir, 'temp.product')
	        renderTemplate(Helper.resolveTemplate(project, 'products/template.product'), productFileTemp, productDef)
	
	        // set environment variable to the path to the new temporary
	        // product file, so subsequent tasks can use it
	        project.ext.productFile = productFileTemp.path
	
			// set tag from product definition
			project.ext.tag = productDef['Tag']
	
	        // set global variables for additional files so
	        // subsequent tasks can use it
	        // if (productDef['IncludeMongoDB'] != null) {
	        //     project.ext.includeMongoDB = productDef['IncludeMongoDB']
	        // }
	        // if (productDef['IncludeTranscoder'] != null) {
	        //     project.ext.includeTranscoder = productDef['IncludeTranscoder']
	        // }
	        if (productDef['AdditionalFiles'] != null) {
	            project.ext.additionalFilesToPackage = productDef['AdditionalFiles']
	        }
	    }
	}
}

task createProductFeature(dependsOn: [ generatePomFiles, makeProductFile, makeProductFeatureProjectDefinition ]) {
	doLast {
	    def pg = new PomGenerator(project)
	
	    //create pom.xml
	    def productFeaturePath = makeProductFeatureProjectDefinition.destinationDir
	    pg.makePomFileWithPackaging(productFeaturePath.name, '1.0.0', false, false, 'eclipse-repository',
	            'pom-product.xml', productFeaturePath)
	
	    // create build.properties
	    def productFile = getProductFile()
	    new File(productFeaturePath, 'build.properties').withWriter {
	        it << "bin.includes = ${productFile}\n"
	    }
	
	    def shortProductFile = new File(productFile).name
	    pg.generateParentPomFile([ (productFeaturePath.name): [ 'path': productFeaturePath ] ])
	    project.delete(fileTree(dir: productFeaturePath, include: '*.product'))
	    copy {
	        from productFile
	        into productFeaturePath
	    }
	
		new File("$productFeaturePath/HALE.p2.inf").text = '''
	instructions.configure=\
	  addRepository(location:http${#58}//hale-geoserver.geo-solutions.it/,type:0,name:GeoServer App-Schema Plug-in for hale studio,enabled:true);\
	  addRepository(location:http${#58}//hale-geoserver.geo-solutions.it/,type:1,name:GeoServer App-Schema Plug-in for hale studio,enabled:true);\
	  addRepository(location:https${#58}//interactive-instruments.github.io/xtraserver-plugin-for-hale/,type:0,name:XtraServer Plug-in for hale studio,enabled:true);\
	  addRepository(location:https${#58}//interactive-instruments.github.io/xtraserver-plugin-for-hale/,type:1,name:XtraServer Plug-in for hale studio,enabled:true);
	'''
	
	    // remove platform-specific fragments from product
	    // FIXME remove this once Tycho knows how to handle platform-specific
	    // fragments on its own. See BUG 342890
	    // https://bugs.eclipse.org/bugs/show_bug.cgi?id=342890
	    def dstProductFile = new File(productFeaturePath, shortProductFile)
	    filterPlatformSpecificFragments(dstProductFile)
	
	    // replace relative paths to launcher icons by absolute ones
	    // Note: the icon paths are usually specified as relative paths to
	    // resources in a bundle. Therefore the paths contain the bundle's symbolic
	    // name. Eclipse PDE knows how to handle that, but Tycho doesn't. Tycho
	    // expects the icon path point to a local file (i.e. a relative or absolute
	    // file path). Hence, we have to replace the symbolic name by an absolute
	    // file path on our own.
	    replaceIconPaths(dstProductFile)
	}	
}


/**
 * Builds a product. Uses the product specified with the properties
 * 'productType' (either 'client' or 'server') and 'productName' (one of
 * the names defined in 'templates/products/client.yaml' or
 * 'templates/products/server.yaml'). Alternatively you can specify
 * a path to a product file manually with the 'productFile' property.
 */
task buildProduct(dependsOn: createProductFeature) {
	doLast {
		def projectRoot = project.ext.rootDir.path
	    def res = Helper.runMaven(['-e', 'package'], project.ext.rootDir, [
    		(MavenCli.MULTIMODULE_PROJECT_DIRECTORY): projectRoot,
    		// attempt to work around issue on GitHub Actions where downloading dependencies with Maven fails
    		'maven.wagon.httpconnectionManager.ttlSeconds': '120'
    	])
	    if (res != 0) {
	        throw new RuntimeException("Maven failed with exit code ${res}")
	    }
	
	    // extract zip file which has been created by Tycho
	    def tychoOutputProductName = getProductUid() + '-' + project.ext.osgiOS + '.' +
	            project.ext.osgiWS + '.' + project.ext.osgiArch
	    def productFeaturePath = makeProductFeatureProjectDefinition.destinationDir
		def productOutputPath = new File(buildDir, getProductUid())
		if (Helper.buildForWindows(project)) {
			def tychoOutputProductZip = new File(productFeaturePath, "target/products/${tychoOutputProductName}.zip")
			project.delete(productOutputPath)
			ant.unzip(src: tychoOutputProductZip, dest: productOutputPath)
		} else {
			def tychoOutputProductZip = new File(productFeaturePath, "target/products/${tychoOutputProductName}.tar.gz")
			project.delete("${productOutputPath}.tar")
			project.delete(productOutputPath)
		    println('Extracting product ...')
		    
		    ant.gunzip(src: tychoOutputProductZip, dest: "${productOutputPath}.tar")
			ant.untar(src: "${productOutputPath}.tar", dest: productOutputPath)
	//	    ant.unzip(src: tychoOutputProductZip, dest: productOutputPath)
		}
	    // Include JRE if available for this platform
	    includeAdditionalFiles(project.ext.jreArtifacts, 'jre', productOutputPath, 'jre', 'JRE')
	
	    // Include additional files
	     if (project.ext.includeMongoDB) {
	         includeAdditionalFiles(project.ext.mongodbArtifacts, 'mongodb', productOutputPath, 'mongodb', 'MongoDB')
	     }
	    if (productContainsHaleIOBundles()) {
	        includeAdditionalFiles(project.ext.spatialiteArtifacts, 'spatialite', productOutputPath, '', 'Spatialite')
	    }
	    if (!project.ext.additionalFilesToPackage.isEmpty()) {
	        println('Copying additional files ...')
	        project.ext.additionalFilesToPackage.each { af ->
	            project.copy {
	                from Helper.resolveTemplate(project, 'additional_files')
					include af
	                into productOutputPath
	            }
	        }
	    }
	
		updateAboutInfo(productOutputPath)
	}	
}

/**
 * Packages a built product.
 */
task packageProduct(dependsOn: buildProduct) {
	doLast {
		def productOutputPath = new File(buildDir, getProductUid())
	
		if (productContainsUIBundles()) {
			packageClient(productOutputPath)
		} else {
			packageServer(productOutputPath)
		}
	}
}

/**
 * Run the test product launcher
 * @param args list of additional arguments
 */
def runTests(args = []) {
	def productOutputPath = new File(buildDir, getProductUid())
	def launcherName = project.ext.testProductLauncher?:'eclipse'
	def testReportDir = project.file('target/testReports')
	testReportDir.mkdirs()

	File outFile = new File(testReportDir, "${launcherName}.out")
	File errFile = new File(testReportDir, "${launcherName}.err")
	File reportFile = new File(testReportDir, "${launcherName}.xml")
	File launcherFile = new File(productOutputPath, launcherName)
	
	// remove files to be sure to have up-to-date files
	outFile.delete()
	errFile.delete()
	reportFile.delete()
	
	// make launcher executable
	ant.chmod(file: launcherFile, perm:'a+x')
	// make JRE executable (linux)
	ant.chmod(dir: new File(productOutputPath, 'jre/bin'), perm: 'a+x', includes: '*')

	println 'Starting test product...'
	outFile.withOutputStream { out ->
		errFile.withOutputStream { err ->
			def process = ([
				launcherFile as String,
				'-out',
				reportFile as String
			] + args).execute()
			process.waitForProcessOutput(out, err)
			if (process.exitValue() != 0) {
				throw new IllegalStateException("Test product failed with exit code ${process.exitValue()}")
			}
		}
	}
	println 'Test product execution completed.'

	// evaluate test report
	def root = new groovy.util.XmlSlurper().parse(reportFile)
	def failures = root.@failures as String
	
	// print failures
	if (failures && failures != '0') {
		println '>>> Test failures: '
		root.testcase.each { test ->
			if (test.failure.size() > 0) {
				def testClass = test.@classname as String
				def testName = test.@name as String

				println "> ${testClass}:${testName}"
				println test.failure[0].text()
				println()
			}
		}
	}

	println '>>> Test summary'
	println "> ${root.@tests} tests"
	println "> ${root.@errors} errors"
	println "> ${failures} failed"
	println "> ${root.@skip} skipped"
	println "in ${root.@time} seconds"
	
	if (failures && failures != '0') {
		throw new RuntimeException("$failures tests failed")
	}
}

/**
 * Runs the OSGi unit tests. This method does not fail the build if one
 * unit test fails.
 */
task runUnitTests(dependsOn: buildProduct) {
	doLast {
		runTests(['-unit'])
	}
}

/**
 * Runs the OSGi unit and integration tests. This method does not fail the build if one
 * unit test fails.
 */
task runAllTests(dependsOn: buildProduct) {
	doLast {
		runTests(['-unit', '-integration'])
	}	
}

/**
 * Runs the commit stage. The commit stage includes building all sources,
 * creating binary artifacts and running unit tests.
 */
task commitStage(dependsOn: runUnitTests)

/**
 * Runs the integration stage. The integration stage includes building all sources,
 * creating binary artifacts and running unit and integration tests.
 */
task integrationStage(dependsOn: runAllTests)
