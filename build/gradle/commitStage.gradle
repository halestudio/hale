// Fraunhofer Institute for Computer Graphics Research (IGD)
// Department Graphical Information Systems (GIS)
//
// Copyright (c) 2004-2013 Fraunhofer IGD. All rights reserved.
//
// This source code is property of the Fraunhofer IGD and underlies
// copyright restrictions. It may only be used with explicit
// permission from the respective owner.

//buildscript {
//    dependencies {
//        classpath files('depchk/jdepchk.jar')
//    }
//}

import groovy.text.GStringTemplateEngine
import groovy.xml.MarkupBuilder
import org.apache.maven.cli.MavenCli

task createUpdateSiteFeatureProjectDefinition(type: Copy) {
    from 'templates/plugin-project.xml'
    into new File(buildDir, 'de.cs3d.updatesite.feature')
    rename { '.project' }
}

/**
 * Creates the update site feature's feature.xml file
 * This file has to be re-created every time a new build is started in
 * order to update all projects.
 * The feature will include all workspace bundles as well as the target
 * platform bundles referenced in the defaultLaunchConfiguration file
 */
task createUpdateSiteFeature(dependsOn: createUpdateSiteFeatureProjectDefinition) << {
    // create pom.xml
    def updateSiteFeaturePath = createUpdateSiteFeatureProjectDefinition.destinationDir
    new PomGenerator(project).makePluginPomFileWithPackaging(updateSiteFeaturePath.name, '1.0.0', false,
            false, 'eclipse-feature', updateSiteFeaturePath)

    // create build.properties
    new File(updateSiteFeaturePath, 'build.properties').withWriter {
        it << "bin.includes = feature.xml\n"
    }

    // read defaultLaunchConfiguration
    def targetPlugins = []
    def dutlc = new XmlSlurper().parse(project.ext.defaultUnitTestLaunchConfiguration)
    dutlc.stringAttribute.each { sa ->
        if (sa.@key.toString() == 'selected_target_plugins') {
            def value = sa.@value.toString()
            value.split(',').each { e ->
                def bundleAndVersion = e.split('@')[0].split(/\*/).toList()
                if (bundleAndVersion.size() < 2) {
                    bundleAndVersion += '0.0.0'
                }
        
                // FIXME remove this, once the bug in the OSGi bundle has been
                // fixed and we don't need the extra bundle anymore
                def id = bundleAndVersion[0]
                if (id == 'org.eclipse.osgi') {
                  bundleAndVersion[1] = '0.0.0'
                }

                // Filter platform-specific bundles
                def skipBundle = false
                if (id.contains('x86') || id.contains('i586')) {
                    // found a platform-specific bundle
                    // check architecture
                    def is64bit = id.contains('x86_64')
                    if (is64bit != Helper.buildFor64bit(project)) {
                        skipBundle = true
                    } else {
                        // check OS
                        if (!id.contains(project.ext.osgiOS)) {
                            skipBundle = true
                        }
                    }
                }

                if (!skipBundle) {
                    targetPlugins << [ id, bundleAndVersion[1] ]
                }
            }
        }
    }

    new File(updateSiteFeaturePath, 'feature.xml').withWriter { w ->
        def xml = new MarkupBuilder(w)
        xml.mkp.xmlDeclaration(version: '1.0', encoding: 'utf-8')
        xml.feature('id': updateSiteFeaturePath.name, 'label': updateSiteFeaturePath.name, 'version': '1.0.0') {
            // add workspace plugins
            new BundleParser(project).getParsedBundles().each {
                plugin('id': it.key, 'version': '0.0.0')
            }
            // add required target platform plugins
            targetPlugins.each {
                plugin('id': it[0], 'version': it[1])
            }
        }
    }
}

/**
 * Build all bundles and assemble update site needed for testing
 */
task buildUpdateSite(dependsOn: [ createUpdateSiteFeature, generatePomFiles ]) << {
    def pg = new PomGenerator(project)

    // create pom file
    def updateSitePath = new File(buildDir, 'de.cs3d.updatesite')
    updateSitePath.mkdirs()
    pg.makePomFileWithPackaging(updateSitePath.name, '1.0.0', false, false, 'eclipse-repository',
            'pom-repository.xml', updateSitePath)

    // create category.xml
    new File(updateSitePath, 'category.xml').withWriter { w ->
        def template = new GStringTemplateEngine().createTemplate(Helper.resolveTemplate(project, 'category.xml'))
        def result = template.make([
            'featureId': createUpdateSiteFeatureProjectDefinition.destinationDir.name,
            'version': '1.0.0',
        ]).toString()
        w << result
    }

    // generate parent pom file and add update site module(s)
    pg.generateParentPomFile([
        (updateSitePath.name): [
            'version': '1.0.0',
            'path': updateSitePath
        ],
        (createUpdateSiteFeatureProjectDefinition.destinationDir.name): [
            'version': '1.0.0',
            'path': createUpdateSiteFeatureProjectDefinition.destinationDir
        ]
    ])

    // build update site
    def res = new MavenCli().doMain([ 'package' ] as String[], project.ext.rootDir.path, System.out, System.err)
    if (res != 0) {
        throw new RuntimeException("Maven failed with exit code ${res}")
    }

    // delete junit3 bundle (because during unit testing it conflicts
    // with junit4 and we don't need it anyway)
    // Note: Only the jar file will be deleted, leaving the update site
    // in an invalid state (content.xml is not updated)
    def updateSitePlugins = new File(updateSitePath, 'target/repository/plugins')
    def junit3bundle = fileTree(dir: updateSitePlugins, include: 'org.junit_3*.jar')
    junit3bundle.each { it.delete() }
}

/**
 * Runs the OSGi unit tests. This method does not fail the build if one
 * unit test fails.
 */
task runUnitTests(dependsOn: buildUpdateSite) << {
    new UnitTestRunner(project).executeUnitTests(project.ext.testBundlePattern)
}

/**
 * Runs the commit stage. The commit stage includes building all sources,
 * creating binary artifacts (in this case an update site containing all
 * exported bundles) and running unit tests.
 */
task commitStage(dependsOn: runUnitTests)
