<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Mapping Documentation</title>

    <script type="text/javascript" src="http://snapsvg.io/assets/js/snap.svg-min.js"></script>
    
    <style>
        .infoCircle:hover {
            cursor: pointer;
        }

        .mappingContainer {
            width: 820px;
            padding: 10px
        }

        .svgContainer {
            border: 1px solid black;
            width: 100%;
        }

        .propertyContainer {
            position: relative;
            width: 100%;
        }

        .closeButton {
            color: #f4d887;
            font-weight: bold;
            position: absolute;
            right: 0px;
            height: 100%;
            padding: 5px 10px;
            background-color: #4a4a4a;
            border-bottom-right-radius: 10px;
        }

        .closeButton:hover {
            cursor: pointer;
            color: #fcf0c3;
            text-decoration: underline;
        }

        .propertyTable {
            width: 98%;
            border-bottom-right-radius: 10px;
        }

        tr {
            background-color: #e0edf4;
            border: 1px solid #4a4a4a;
            width: 100%
        }

        tr:nth-child(even) {
            background-color: #a8d0f4;
            border: 1px solid #4a4a4a;
        }

        tr:last-child {
            border-bottom-left-radius: 10px;
        }

        td {
            padding: 5px;
            font-size: 14px;
        }

        .keyCell {
            font-style: italic;
        }


    </style>

    <!-- js for drawing the mapping tree -->
    <script type="text/javascript">

        /**
         * Returns the number of rows needed to draw a cell.
         * @param cell the Cell for which to calculate the height.
         * @param whitespaceRows the LNumber of rows to use as whitespace in between paths.
         */
        function calculateHeight(cell, whitespaceRows, side) {
            var elements = cell.targets;
            if (side === "source") {
                elements = cell.sources;
            }
            var totalTargetRows = (elements.length - 1) * whitespaceRows;
            for (var j = 0; j < elements.length; j++) {
                totalTargetRows += elements[j].propertyPath.length;
            }
            return totalTargetRows;
        }

        function getLengthOfLongestElement(thisList) {
            var longestPathElementLength = 0;
            for (var k = 0; k < thisList.length; k++) {
                if (thisList[k].length > longestPathElementLength) {
                    longestPathElementLength = thisList[k].length ;
                }
            }
            return longestPathElementLength;
        }

        function getInitialShape(startX, startY, lineHeight, longestPathElementLength, charLength) {
            return [ // generic shape that is later modified.
                startX, startY,
                startX, startY - lineHeight,
                startX - ((longestPathElementLength + 4) * charLength), startY - lineHeight,
                startX - ((longestPathElementLength + 4) * charLength), startY - lineHeight,
                startX - ((longestPathElementLength + 4) * charLength) - lineHeight/2, startY - lineHeight/2,
                startX - ((longestPathElementLength + 4) * charLength), startY
            ];
        }

        function getPathPolyCoords(thisPath, side, coordinates, k, lineHeight, paddingXShift, paddingYShift, myWidth) {
            // default is a target side geometry

            var targetNameCoordinates = [];
            for (var l = 0, len = coordinates.length; l < len; l++) {
                targetNameCoordinates[l] = coordinates[l];
            }
            // adjust x values
            targetNameCoordinates[0] += (thisPath.length - k) * 5;
            targetNameCoordinates[2] += (thisPath.length - k) * 5;
            targetNameCoordinates[4] -= 5 + (thisPath.length - k - 1) * paddingXShift;
            targetNameCoordinates[6] -= 5 + (thisPath.length - k - 1) * paddingXShift;
            targetNameCoordinates[8] -= (thisPath.length - k) * 5;
            targetNameCoordinates[10] -= 5 + (thisPath.length - k - 1) * paddingXShift;

            // adjust y values
            targetNameCoordinates[1] += (thisPath.length - k - 1) * paddingYShift;
            targetNameCoordinates[3] -= (thisPath.length - k - 1) * lineHeight;
            targetNameCoordinates[5] -= (thisPath.length - k - 1) * lineHeight;
            targetNameCoordinates[7] -= (thisPath.length - k - 1 ) * paddingYShift;
            targetNameCoordinates[11] += (thisPath.length - k - 1 ) * paddingYShift;

            if (side === "source") {
                for (var i = 0; i < targetNameCoordinates.length; i += 2) {
                    targetNameCoordinates[i] = myWidth - targetNameCoordinates[i];
                }
            }
            return targetNameCoordinates;
        }
        
        function drawSourcesTargets(s, side, cell, whitespaceRows, myWidth, myHeight, lineHeight, charLength,
                                    paddingXShift, paddingYShift, functionNameCoordinates, shadowFilter, elementId) {
            // calculate number of rows needed
            var totalRows = calculateHeight(cell, whitespaceRows, side);

            var nextRowToFill = 1;
            var elements = cell.targets;
            var mirrorFactor = 1;
            if (side === "source") {
                elements = cell.sources;
                mirrorFactor = -1;
            }
            for (var j = 0; j < elements.length; j++) {
                var thisPath = elements[j].propertyPath;
                var longestPathElementLength = getLengthOfLongestElement(thisPath);

                if (longestPathElementLength < 2) {
                    longestPathElementLength = 2;
                }

                var startX = myWidth - 5 * (thisPath.length + 1);
                nextRowToFill += (thisPath.length - 1);
                var startY = (myHeight / 2) + (nextRowToFill - (totalRows / 2.0)) * lineHeight;
                nextRowToFill +=  whitespaceRows + 1;
                var basicCoordinates = getInitialShape(startX, startY, lineHeight, longestPathElementLength, charLength);

                for (var k = 0; k < thisPath.length; k++) {
                    var targetNameCoordinates = getPathPolyCoords(
                            thisPath, side, basicCoordinates, k, lineHeight, paddingXShift, paddingYShift, myWidth);

                    var targetNameShape = s.polygon(targetNameCoordinates).attr({
                        stroke: "#000000",
                        fill: "#e9c551",
                        "fill-opacity": 0.5
                    });
                    if (k === 0) {
                        targetNameShape.attr({filter: shadowFilter});
                    }
                    var targetNameText = s.text(targetNameCoordinates[0] - 30 * mirrorFactor, targetNameCoordinates[3] + (lineHeight - 7), thisPath[k]).attr({
                        "font-size": "14px"
                    });
                    if (side === "target") {
                        targetNameText.attr({"text-anchor": "end"});
                    };
                    var iCircleID = elementId + "_iCircle_" + side + "_" + j + "_" + k;
                    var iCircle = s.circle(targetNameCoordinates[0] - 12 * mirrorFactor, targetNameCoordinates[3] + (lineHeight / 2), (lineHeight / 2) - 4).attr({
                        "stroke": "#000000",
                        "fill": "#f4d887",
                        "class": "infoCircle",
                        "id": iCircleID
                    });
                    var iMark = s.text(targetNameCoordinates[0] - 12 * mirrorFactor, targetNameCoordinates[3] + (lineHeight - 7), "i").attr({
                        "font-weight": "bold",
                        "font-size": "14px",
                        "class": "infoCircle",
                        "text-anchor": "middle"
                    });

                    var infoGroupID = elementId + "_infoGroup_" + side + "_" + j + "_" + k;
                    var infoGroup = s.g(iCircle, iMark).attr( {
                        "id": infoGroupID
                    });

                    (function() {
                        var selectID = "#" + iCircleID;
                        var propertyDisplayID = elementId + "_properties";
                        if (elements[j].propertyDescriptions != null) {
                            var thisPropertyDescription = elements[j].propertyDescriptions[k];
                            Snap.select("#" + infoGroupID).hover(
                                function() { // f_in handler
                                    Snap.select(selectID).attr({"fill": "#fcf0c3"});
                                },
                                function() { // f_out handler
                                    Snap.select(selectID).attr({"fill": "#f4d887"});
                                }
                            ).click(
                                    function () {
                                        displayAttributeProperties(propertyDisplayID, thisPropertyDescription);
                                    }
                            );
                        }
                        else {
                            iCircle.attr({
                                "fill": "#CCCCCC",
                            })
                        }
                    })();
                }
                // draw connecting lines
                drawConnectorLine(s, functionNameCoordinates, basicCoordinates, side, myWidth);
            }
        }

        function displayAttributeProperties(elemID, propertyDescription) {
            // add all attributes for a given propertyDescription to the Div below the SVG area
            if (propertyDescription != null) {
                var propertyDiv = document.getElementById(elemID);

                // remove any children that are present.
                while (propertyDiv.firstChild) {
                    propertyDiv.removeChild(propertyDiv.firstChild);
                }

                // create a DIV for the "close" button
                var closeDiv = document.createElement("div");
                closeDiv.appendChild(document.createTextNode("close"));
                closeDiv.className = "closeButton";
                closeDiv.onclick = function() {
                    while (propertyDiv.firstChild) {
                        propertyDiv.removeChild(propertyDiv.firstChild);
                    }
                }
                propertyDiv.appendChild(closeDiv);

                // create table for object properties
                var prpTable = document.createElement("table");
                prpTable.className = "propertyTable";
                propertyDiv.appendChild(prpTable);
                for (var aProperty in propertyDescription) {
                    var prpRow = prpTable.insertRow();
                    var prpKeyCell = prpRow.insertCell(0);
                    prpKeyCell.className = "keyCell";
                    var prpValueCell = prpRow.insertCell(1);
                    prpValueCell.className = "valueCell";
                    prpKeyCell.appendChild(document.createTextNode(aProperty));
                    prpValueCell.appendChild(document.createTextNode(propertyDescription[aProperty]));
                }
            }
        }

        function drawConnectorLine(s, functionNameCoordinates, basicCoordinates, side, myWidth) {
            var deltaX = Math.abs(functionNameCoordinates[4] - basicCoordinates[8]) / 2.5;
            var pathD = [
                functionNameCoordinates[4] , functionNameCoordinates[5],
                functionNameCoordinates[4] + deltaX , functionNameCoordinates[5],
                basicCoordinates[8] - deltaX, basicCoordinates[9],
                basicCoordinates[8], basicCoordinates[9]
            ];
            if (side === "source") {
                for (var i = 0; i < pathD.length; i += 2) {
                    pathD[i] = myWidth - pathD[i];
                }
            }
            s.path("M " + pathD[0] + " " + pathD[1] + " C " + pathD[2] + " " + pathD[3] + " " + pathD[4] + " " + pathD[5] + " " + pathD[6] + " " + pathD[7]).attr({
                "fill": "none",
                "stroke": "#000000",
                "stroke-width": 3
            });
        }

        /**
         *  Draw a set of cells using Snap.svg to a SVG element already existing in the DOM.
         * @param elementId the ID of the SVG element into which to draw.
         * @param thisCell the Cell to be drawn.
         * @param options options for controlling the drawing behaviour (optional)
         */
        function drawMapping(elementId, thisCell, options) {
            var s = Snap(elementId);

            // set default values for parameters
            var myWidth = 800;
            var fNameBoxHeight = 24;
            var whitespaceRows = 2;
            var padding = 5;
            var charLength = 6;

            // overwrite defaults if they were set in the options object.
            if (options != null) {
                if (options.width != null) { myWidth = options.width };
                if (options.lineHeight != null) { fNameBoxHeight = options.lineHeight };
                if (options.padding != null) { padding = options.padding };
                if (options.charLength != null) { charLength = options.charLength };
            }

            var sourceHeight = calculateHeight(thisCell, whitespaceRows, "source") + 1.5;
            var targetHeight = calculateHeight(thisCell, whitespaceRows, "target") + 1.5;
            var myHeight = sourceHeight > targetHeight ? sourceHeight * fNameBoxHeight : targetHeight * fNameBoxHeight;
            document.getElementById(elementId.substr(1)).style.height = myHeight + "px";
            var paddingYShift = Math.sqrt(0.5 * padding * padding);
            var paddingXShift = Math.sqrt(0.5 * paddingYShift * paddingYShift);
            var shadowFilter = s.filter(Snap.filter.shadow(2, 2, 3, "#999999"));

            // draw function name & parameter elements
            var paramMaxlength = 0;
            var paramCount = thisCell.functionParameters.length;

            for (var j = 0; j < thisCell.functionParameters.length; j++) {
                var thisParam = thisCell.functionParameters[j];
                var thisParamlength = thisParam.paramLabel.length + thisParam.paramValue.length;
                if (thisParamlength > paramMaxlength) {
                    paramMaxlength = thisParamlength;
                }
            }
            var nameLength = thisCell.functionName.length * 1.333; // add additional space for parameters and long function names

            var startX = (myWidth / 2) - ((nameLength + 4) * charLength/2);
            var startY = (myHeight / 2) + fNameBoxHeight / 2;
            var functionNameCoordinates = [
                startX, startY,
                startX + ((nameLength + 4) * charLength), startY,
                startX + ((nameLength + 4) * charLength) + fNameBoxHeight/2, startY - fNameBoxHeight/2,
                startX + ((nameLength + 4) * charLength), startY - fNameBoxHeight,
                startX, startY - fNameBoxHeight,
                startX - fNameBoxHeight/2, startY - fNameBoxHeight/2
            ];

            var functionNameShape = s.polygon(functionNameCoordinates).attr({
                stroke: "#000000",
                fill: "#a8d0f4",
                filter: shadowFilter
            });
            var functionNameText = s.text(startX + 2, myHeight / 2 + 5,thisCell.functionName);
            var helpCircle = s.circle(startX + ((nameLength + 3) * charLength), myHeight / 2, (fNameBoxHeight / 2) - 4).attr({
                "stroke": "#000000",
                "fill": "#f4d887",
                "font-size": "14px",
                "class": "infoButton"
            });
            var helpQMark = s.text(startX + ((nameLength + 3) * charLength) - 5, myHeight / 2 + 5, "?").attr({
                "font-weight": "bold",
                "font-size": "14px"
            });
            var qmarkGroup = s.g(helpCircle, helpQMark);
            qmarkGroup.hover(
                    function() { // f_in handler
                        helpCircle.attr({
                            "fill": "#fcf0c3",
                            "r": (fNameBoxHeight / 2) - 3
                        });
                    },
                    function() { // f_out handler
                        helpCircle.attr({
                            "fill": "#f4d887",
                            "r": (fNameBoxHeight / 2) - 4
                        });
                    }
            ) ;
            var paramKVShape = s.rect(startX, startY, ((nameLength + 4) * charLength), (1 + paramCount * 0.75) * fNameBoxHeight).attr({
                stroke: "#000000",
                fill: "#a8d0f4",
                filter: shadowFilter
            });
            s.text(startX + 4, startY + 18, "Parameters").attr({
                "font-size": "12px",
                "font-style": "italic"
            });
            for (var j = 0; j < thisCell.functionParameters.length; j++) {
                s.text(startX + 4, startY + fNameBoxHeight + 12 + (fNameBoxHeight - 6) * j, thisCell.functionParameters[j].paramLabel).attr({
                    "font-size": "12px"
                });
            }
            for (var j = 0; j < thisCell.functionParameters.length; j++) {
                s.text(
                            startX + ((nameLength + 4) * charLength) - 4,
                            startY + fNameBoxHeight + 12 + (fNameBoxHeight - 6) * j,
                            thisCell.functionParameters[j].paramValue).attr({
                                "font-size": "12px",
                                "text-anchor": "end"
                });
            }

            // draw source elements.................................................................................
            drawSourcesTargets(
                    s, "source", thisCell, whitespaceRows, myWidth, myHeight, fNameBoxHeight, charLength,
                    paddingXShift, paddingYShift, functionNameCoordinates, shadowFilter, elementId.substr(1));

            // draw target elements.................................................................................
            drawSourcesTargets(
                    s, "target", thisCell, whitespaceRows, myWidth, myHeight, fNameBoxHeight, charLength,
                    paddingXShift, paddingYShift, functionNameCoordinates, shadowFilter, elementId.substr(1));
        }
    </script>
    </head>
<body>

	<!-- Project info -->
	<% if (project) { %>
	<div>
		<h1>$project.name</h1>
		<h3>$project.author</h3> 
		<% if (project.description) { %>
			<p>$project.description</p>
		<% } %>
	</div>
	<% } %>

	<!-- Overview? -->
	
	<!-- All cells unordered -->
    <div class="mappingContainer">
   	<% alignment.cells.each { %>
        <h1>Cell ${it.key}:</h1>
        <svg id="mapping_${it.key}" class="svgContainer"></svg>
        <div id="mapping_${it.key}_properties" class="propertyContainer"></div>
    <% } %>
    </div>

    <script>
        window.onload = function() {
       	<% alignment.cells.each { %>
	        drawMapping("#mapping_${it.key}", $it.value, {
	            width: 800,
	            lineHeight: 24,
	            padding: 5,
	            charLength: 6
	        });
        <% } %>
        }
    </script>

</body>
</html>