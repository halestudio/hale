/*
 * Copyright (c) 2015 Data Harmonisation Panel
 * 
 * All rights reserved. This program and the accompanying materials are made
 * available under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, either version 3 of the License,
 * or (at your option) any later version.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this distribution. If not, see <http://www.gnu.org/licenses/>.
 * 
 * Contributors:
 *     Data Harmonisation Panel <http://www.dhpanel.eu>
 */

package eu.esdihumboldt.hale.io.appschema.writer.internal;

import static eu.esdihumboldt.hale.io.appschema.writer.internal.AppSchemaMappingUtils.findOwningFeatureType;
import static eu.esdihumboldt.hale.io.appschema.writer.internal.AppSchemaMappingUtils.getTargetProperty;
import static eu.esdihumboldt.hale.io.appschema.writer.internal.AppSchemaMappingUtils.getTargetType;
import static eu.esdihumboldt.hale.io.appschema.writer.internal.AppSchemaMappingUtils.isGeometryType;
import static eu.esdihumboldt.hale.io.appschema.writer.internal.AppSchemaMappingUtils.isGmlId;
import static eu.esdihumboldt.hale.io.appschema.writer.internal.AppSchemaMappingUtils.isXmlAttribute;

import java.util.List;

import javax.xml.namespace.QName;

import eu.esdihumboldt.hale.common.align.model.AlignmentUtil;
import eu.esdihumboldt.hale.common.align.model.Cell;
import eu.esdihumboldt.hale.common.align.model.ChildContext;
import eu.esdihumboldt.hale.common.align.model.Condition;
import eu.esdihumboldt.hale.common.align.model.EntityDefinition;
import eu.esdihumboldt.hale.common.align.model.Property;
import eu.esdihumboldt.hale.common.align.model.impl.PropertyEntityDefinition;
import eu.esdihumboldt.hale.common.schema.model.Definition;
import eu.esdihumboldt.hale.common.schema.model.PropertyDefinition;
import eu.esdihumboldt.hale.common.schema.model.TypeDefinition;
import eu.esdihumboldt.hale.io.appschema.impl.internal.generated.app_schema.AttributeExpressionMappingType;
import eu.esdihumboldt.hale.io.appschema.impl.internal.generated.app_schema.AttributeMappingType;
import eu.esdihumboldt.hale.io.appschema.impl.internal.generated.app_schema.AttributeMappingType.ClientProperty;
import eu.esdihumboldt.hale.io.appschema.impl.internal.generated.app_schema.NamespacesPropertyType.Namespace;
import eu.esdihumboldt.hale.io.appschema.impl.internal.generated.app_schema.TypeMappingsPropertyType.FeatureTypeMapping;
import eu.esdihumboldt.hale.io.xsd.constraint.XmlAttributeFlag;

/**
 * Base class for property transformation handlers.
 * 
 * @author Stefano Costa, GeoSolutions
 */
public abstract class AbstractPropertyTransformationHandler implements
		PropertyTransformationHandler {

	/**
	 * The app-schema mapping configuration under construction.
	 */
	protected AppSchemaMappingWrapper mapping;
	/**
	 * The property cell to handle.
	 */
	protected Cell propertyCell;
	/**
	 * The target property.
	 */
	protected Property targetProperty;

	/**
	 * The feature type mapping which is the parent of the attribute mapping
	 * generated by this handler.
	 */
	protected FeatureTypeMapping featureTypeMapping;
	/**
	 * The attribute mapping generated by this handler.
	 */
	protected AttributeMappingType attributeMapping;

	/**
	 * 
	 * @see eu.esdihumboldt.hale.io.appschema.writer.internal.PropertyTransformationHandler#handlePropertyTransformation(eu.esdihumboldt.hale.common.align.model.Cell,
	 *      eu.esdihumboldt.hale.io.appschema.writer.internal.AppSchemaMappingWrapper)
	 */
	@Override
	public AttributeMappingType handlePropertyTransformation(Cell typeCell, Cell propertyCell,
			AppSchemaMappingWrapper mapping) {
		this.mapping = mapping;
		this.propertyCell = propertyCell;
		// TODO: does this hold for any transformation function?
		this.targetProperty = getTargetProperty(propertyCell);

		PropertyEntityDefinition targetPropertyEntityDef = targetProperty.getDefinition();
		PropertyDefinition targetPropertyDef = targetPropertyEntityDef.getDefinition();
		TypeDefinition featureType = null;
		if (AppSchemaMappingUtils.isJoin(typeCell)) {
			featureType = findOwningFeatureType(targetPropertyEntityDef);
		}
		if (featureType == null) {
			featureType = getTargetType(typeCell).getDefinition().getType();
		}

		// in a well-formed mapping, should always be != null
		if (featureType != null) {
			// fetch FeatureTypeMapping from mapping configuration
			this.featureTypeMapping = mapping.getOrCreateFeatureTypeMapping(featureType);

			// fetch AttributeMappingType from mapping
			if (isXmlAttribute(targetPropertyDef)) {
				// gml:id attribute requires special handling
				if (isGmlId(targetPropertyDef)
						&& featureType.equals(targetPropertyDef.getParentType())) {
					handleAsGmlId(featureType);
				}
				else {
					handleAsXmlAttribute(featureType);
				}
			}
			else {
				handleAsXmlElement(featureType);
			}
		}

		return attributeMapping;
	}

	/**
	 * This method is invoked when the target property is <code>gml:id</code>,
	 * which needs special handling.
	 * 
	 * <p>
	 * In practice, this means that <code>&lt;idExpression&gt;</code> is used in
	 * place of <code>&lt;sourceExpression&gt;</code> and that the target
	 * attribute is set to the mapped feature type name.
	 * </p>
	 * 
	 * @param featureType the target feature type
	 */
	protected void handleAsGmlId(TypeDefinition featureType) {
		PropertyEntityDefinition targetPropertyEntityDef = targetProperty.getDefinition();
		List<ChildContext> gmlIdPath = targetPropertyEntityDef.getPropertyPath();

		attributeMapping = mapping.getOrCreateAttributeMapping(featureType, gmlIdPath);
		// set targetAttribute to feature type qualified name
		attributeMapping.setTargetAttribute(mapping.getOrCreateFeatureTypeMapping(featureType)
				.getTargetElement());
		// set id expression
		AttributeExpressionMappingType idExpression = new AttributeExpressionMappingType();
		idExpression.setOCQL(getSourceExpressionAsCQL());
		// TODO: not sure whether any CQL expression can be used
		// here
		attributeMapping.setIdExpression(idExpression);
	}

	/**
	 * This method is invoked when the target property is an XML attribute (
	 * {@link XmlAttributeFlag} constraint is set).
	 * 
	 * <p>
	 * The property transformation is translated to:
	 * 
	 * <pre>
	 *   <code>&lt;ClientProperty&gt;
	 *     &lt;name&gt;[target property name]&lt;/name&gt;
	 *     &lt;value&gt;[CQL expression]&lt;/value&gt;
	 *   &lt;/ClientProperty&gt;</code>
	 * </pre>
	 * 
	 * and added to the attribute mapping generated for the XML element owning
	 * the attribute.
	 * </p>
	 * 
	 * @param featureType the target feature type
	 */
	protected void handleAsXmlAttribute(TypeDefinition featureType) {
		PropertyEntityDefinition targetPropertyEntityDef = targetProperty.getDefinition();
		PropertyDefinition targetPropertyDef = targetPropertyEntityDef.getDefinition();

		// fetch attribute mapping for parent property
		EntityDefinition parentDef = AlignmentUtil.getParent(targetPropertyEntityDef);
		if (parentDef != null) {
			List<ChildContext> parentPropertyPath = parentDef.getPropertyPath();
			PropertyDefinition parentPropertyDef = parentPropertyPath
					.get(parentPropertyPath.size() - 1).getChild().asProperty();
			if (parentPropertyDef != null) {
				attributeMapping = mapping.getOrCreateAttributeMapping(featureType,
						parentPropertyPath);
				// set targetAttribute if empty
				if (attributeMapping.getTargetAttribute() == null
						|| attributeMapping.getTargetAttribute().isEmpty()) {
					attributeMapping.setTargetAttribute(mapping.buildAttributeXPath(featureType,
							parentPropertyPath));
				}

				Namespace parentPropNS = mapping.getOrCreateNamespace(parentPropertyDef.getName()
						.getNamespaceURI(), parentPropertyDef.getName().getPrefix());
				Namespace targetPropNS = mapping.getOrCreateNamespace(targetPropertyDef.getName()
						.getNamespaceURI(), targetPropertyDef.getName().getPrefix());
				String unqualifiedName = targetPropertyDef.getName().getLocalPart();
				boolean isQualified = targetPropNS != null
						&& !parentPropNS.getUri().equals(targetPropNS.getUri());

				// encode attribute as <ClientProperty>
				ClientProperty clientProperty = new ClientProperty();
				@SuppressWarnings("null")
				String clientPropName = (isQualified) ? targetPropNS.getPrefix() + ":"
						+ unqualifiedName : unqualifiedName;
				clientProperty.setName(clientPropName);
				clientProperty.setValue(getSourceExpressionAsCQL());

				attributeMapping.getClientProperty().add(clientProperty);
			}
		}
	}

	/**
	 * This method is invoked when the target property is a regular XML element.
	 * 
	 * @param featureType the target feature type
	 */
	protected void handleAsXmlElement(TypeDefinition featureType) {
		PropertyEntityDefinition targetPropertyEntityDef = targetProperty.getDefinition();
		PropertyDefinition targetPropertyDef = targetPropertyEntityDef.getDefinition();
		TypeDefinition targetPropertyType = targetPropertyDef.getPropertyType();

		attributeMapping = mapping.getOrCreateAttributeMapping(featureType,
				targetPropertyEntityDef.getPropertyPath());

		if (isGeometryType(targetPropertyType)) {
			handleXmlElementAsGeometryType(featureType);
		}
		else {
			List<ChildContext> targetPropertyPath = targetPropertyEntityDef.getPropertyPath();
			// set target attribute
			attributeMapping.setTargetAttribute(mapping.buildAttributeXPath(featureType,
					targetPropertyPath));
		}

		// set source expression
		AttributeExpressionMappingType sourceExpression = new AttributeExpressionMappingType();
		// TODO: is this general enough?
		sourceExpression.setOCQL(getSourceExpressionAsCQL());
		attributeMapping.setSourceExpression(sourceExpression);
		if (AppSchemaMappingUtils.isMultiple(targetPropertyDef)) {
			attributeMapping.setIsMultiple(true);
		}
		// TODO: isList?
		// TODO: targetAttributeNode?
		// TODO: encodeIfEmpty?
	}

	/**
	 * This method is invoked when the target property is a GML geometry type.
	 * 
	 * <p>
	 * The target attribute is set to <code>gml:AbstractGeometry</code> and the
	 * concrete geometry type is specified in a
	 * <code>&lt;targetAttributeNode&gt;</code> tag.
	 * </p>
	 * 
	 * @param featureType the target feature type
	 */
	protected void handleXmlElementAsGeometryType(TypeDefinition featureType) {
		PropertyEntityDefinition targetPropertyEntityDef = targetProperty.getDefinition();
		TypeDefinition targetPropertyType = targetPropertyEntityDef.getDefinition()
				.getPropertyType();

		// GeometryTypes require special handling
		QName geomTypeName = targetPropertyType.getName();
		Namespace geomNS = mapping.getOrCreateNamespace(geomTypeName.getNamespaceURI(),
				geomTypeName.getPrefix());
		attributeMapping.setTargetAttributeNode(geomNS.getPrefix() + ":"
				+ geomTypeName.getLocalPart());

		// set target attribute to parent (should be gml:AbstractGeometry)
		// TODO: this is really ugly, but I don't see a better way to do it
		// since HALE renames
		// {http://www.opengis.net/gml/3.2}AbstractGeometry element
		// to
		// {http://www.opengis.net/gml/3.2/AbstractGeometry}choice
		EntityDefinition parentEntityDef = AlignmentUtil.getParent(targetPropertyEntityDef);
		Definition<?> parentDef = parentEntityDef.getDefinition();
		String parentQName = geomNS.getPrefix() + ":" + parentDef.getDisplayName();
		List<ChildContext> targetPropertyPath = parentEntityDef.getPropertyPath();
		attributeMapping.setTargetAttribute(mapping.buildAttributeXPath(featureType,
				targetPropertyPath) + "/" + parentQName);
	}

	/**
	 * Wraps the provided CQL expression in a conditional expression, based on
	 * the filter defined on the property.
	 * 
	 * <p>
	 * TODO: current implementation is broken, don't use it (first argument of
	 * if_then_else must be an expression, cannot be a filter (i.e. cannot
	 * contain '=' sign))!
	 * </p>
	 * 
	 * @param propertyEntityDef the property definition defining the condition
	 * @param cql the CQL expression to wrap
	 * @return a conditional expression wrapping the provided CQL expression
	 */
	protected static String getConditionalExpression(PropertyEntityDefinition propertyEntityDef,
			String cql) {
		if (propertyEntityDef != null) {
			String propertyName = propertyEntityDef.getDefinition().getName().getLocalPart();
			List<ChildContext> propertyPath = propertyEntityDef.getPropertyPath();
			// TODO: conditions are supported only on simple (not nested)
			// properties
			if (propertyPath.size() == 1) {
				Condition condition = propertyPath.get(0).getCondition();
				if (condition != null) {
					String fitlerText = AlignmentUtil.getFilterText(condition.getFilter());
					// remove "parent" references
					fitlerText = fitlerText.replace("parent.", "");
					// replace "value" references with the local name of the
					// property itself
					fitlerText = fitlerText.replace("value", propertyName);

					return String.format("if_then_else(%s, %s, Expression.NIL)", fitlerText, cql);
				}
			}
		}

		return cql;
	}

	/**
	 * Template method to be implemented by subclasses.
	 * 
	 * <p>
	 * This is where the translation logic should go. Basically, the propety
	 * transformation must be converted to a CQL expression producing the same
	 * result.
	 * </p>
	 * 
	 * @return a CQL expression producing the same result as the HALE
	 *         transformation
	 */
	protected abstract String getSourceExpressionAsCQL();

}
